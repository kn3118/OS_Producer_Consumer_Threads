/******************************************************************
 * The Main program with the two functions. A simple
 * example of creating and using a thread is provided.
 ******************************************************************/

#include "helper.h"

using namespace std;

void *producer (void *id);
void *consumer (void *id);


int main (int argc, char **argv)
{
  if (argc != 5) {
    cerr << "Incorrect number of coomand line arguments" << endl;
    return -1;
  }
  else if (check_arg(argv[1]) == -1) {
    cerr << "The input for the size of the queue is invalid" << endl;
    return -1;
  }
  else if (check_arg(argv[2]) == -1) {
    cerr << "The input for the number of jobs to be generated by each producer is invalid" << endl;
    return -1;
  }
  else if (check_arg(argv[3]) == -1) {
    cerr << "The input for the number of producers is invalid" << endl;
    return -1;
  }
  else if (check_arg(argv[4]) == -1) {
    cerr << "The input for the number of consumers is invalid" << endl;
    return -1;
  }
  
  int queue_size = check_arg(argv[1]);
  int no_of_jobs = check_arg(argv[2]);
  int no_of_prod = check_arg(argv[3]);
  int no_of_cons = check_arg(argv[4]);
  
  int prod_queue_index = 0;
  int cons_queue_index = 0;

  srand(time(NULL));

  Shared_data queue[queue_size];

  int sem_id = sem_create(SEM_KEY, 3);

  if (sem_id == -1) {
    cerr << "The sem_id has already been created" << endl;
    if ( sem_close(sem_id) ) {
      cerr << "Failure to close the set of semaphores" << endl;
      return -1;
    }
    return -1;
  }

  sem_init(sem_id, 0, 1); // mutex
  sem_init(sem_id, 1, queue_size); // prod
  sem_init(sem_id, 2, 0); // cons

  if (sem_init(sem_id, 0, 1) == -1 || sem_init(sem_id, 1, queue_size) == -1 || sem_init(sem_id, 2, 0) == -1) {
    cerr << "Problem with semaphore initialization" << endl;
    if ( sem_close(sem_id) ) {
      cerr << "Failure to close the set of semaphores with id " << sem_id << endl;
      return -1;
    }
    return -1;
  }

  pthread_t producerid[no_of_prod];

  bool defined_producerid[no_of_prod];
  for (int i = 0; i < no_of_prod; i++)
    defined_producerid[i] = true;
  
  Producer prod_parameter[no_of_prod];
  
  for (int i = 0; i < no_of_prod; i++) {    
    prod_parameter[i].prod_id = i + 1;
    prod_parameter[i].queue_size = queue_size;
    prod_parameter[i].number_jobs = no_of_jobs;
    prod_parameter[i].sem_id = &sem_id;
    prod_parameter[i].prod_queue_index = &prod_queue_index;
    prod_parameter[i].pointer_queue = queue;
    
    if ( pthread_create (&producerid[i], NULL, producer, (void *) &prod_parameter[i]) != 0) {
      cerr << "Failure to create thread for producer " << i << endl;
      defined_producerid[i] = false;
    }
  }

  pthread_t consumerid[no_of_cons];

  bool defined_consumerid[no_of_cons];
  for (int i = 0; i < no_of_cons; i++)
    defined_consumerid[i] = true;

  Consumer cons_parameter[no_of_cons];

  for (int i = 0; i < no_of_cons; i++) {    
    cons_parameter[i].cons_id = i + 1;
    cons_parameter[i].queue_size = queue_size;
    cons_parameter[i].sem_id = &sem_id;
    cons_parameter[i].cons_queue_index = &cons_queue_index;
    cons_parameter[i].pointer_queue = queue;
    
    if ( pthread_create (&consumerid[i], NULL, consumer, (void *) &cons_parameter[i]) != 0) {
      cerr << "Failure to create thread for consumer " << i << endl;
      defined_consumerid[i] = false;
    }
  }

  for (int i = 0; i < no_of_prod; i++)
    if (defined_producerid[i]) 
      pthread_join (producerid[i], NULL);

  for (int i = 0; i < no_of_cons; i++)
    if (defined_consumerid[i])
      pthread_join (consumerid[i], NULL);

  if ( sem_close(sem_id) ) {
    cerr << "Failure to close the set of semaphores with id " << sem_id << endl;
    return -1;
  }
  
  return 0;
}

void *producer (void *parameter) 
{
  Producer* param = (Producer*) parameter;

  int prod_id = param->prod_id;
  int queue_size = param->queue_size;
  int number_jobs = param->number_jobs;
  int* sem_id = param->sem_id;
  int* prod_queue_index = param->prod_queue_index;
  Shared_data* pointer_queue = param->pointer_queue;
  int jobs_left = number_jobs;

  while (true) {

    if (jobs_left == 0) {
      fprintf(stdout, "Producer(%d): No more jobs to generate. \n", prod_id);
      pthread_exit(0);
    }

    if (sem_timedwait(*sem_id, 1) == -1) {
      fprintf(stdout, "Producer(%d): Quits because no jobs arrived for 20 seconds \n", prod_id);
      pthread_exit(0);
    }

    sem_wait(*sem_id, 0); // Lock the Critical Section
    sleep(rand() % 5 + 1);
    pointer_queue[*prod_queue_index % queue_size].id = (*prod_queue_index % queue_size) + 1;
    pointer_queue[*prod_queue_index % queue_size].duration = rand() % 10 + 1;
    cout << "Producer(" << prod_id << "): Job id " << pointer_queue[*prod_queue_index % queue_size].id << " duration " << pointer_queue[*prod_queue_index % queue_size].duration << endl;
    (*prod_queue_index)++;
    sem_signal(*sem_id, 0); // Unlock the Critical Section
    
    sem_signal(*sem_id, 2);
    jobs_left -= 1;
  }
}

void *consumer (void *id) 
{
  Consumer* param = (Consumer*) id;

  int cons_id = param->cons_id;
  int queue_size = param->queue_size;
  int* sem_id = param->sem_id;
  int* cons_queue_index = param->cons_queue_index;
  Shared_data* pointer_queue = param->pointer_queue;
  Shared_data copy_data;

  while (true) {
    
    if (sem_timedwait(*sem_id, 2) == -1) {
      fprintf(stdout, "Consumer(%d): No more jobs left.\n", cons_id);
      pthread_exit(0);
    }
    
    sem_wait(*sem_id, 0); // Lock the Critical Section
    copy_data.id = pointer_queue[*cons_queue_index % queue_size].id;
    copy_data.duration = pointer_queue[*cons_queue_index % queue_size].duration;
    cout << "Consumer(" << cons_id << "): Job id " << copy_data.id << " excecuting sleep duration " << copy_data.duration << endl;
    (*cons_queue_index)++;
    sem_signal(*sem_id, 0); // Unlock the Critical Section
    
    sem_signal(*sem_id, 1);
    sleep(copy_data.duration);
    fprintf(stdout, "Consumer(%d): Job id %d completed \n", cons_id, copy_data.id);
  }
}
